module Mihari
  module Notifiers
    class ExceptionNotifier
      def initialize: () -> void

      def valid?: () -> bool

      def notify: (Exception exception) -> void

      #
      # Send notification to Slack
      #
      # @param [String] text
      # @param [Array<Hash>] attachments
      #
      # @return [nil]
      #
      def notify_to_slack: (text: String text, attachments: Array[Hash[(String | Symbol), untyped]] attachments) -> void

      #
      # Send notification to STDOUT
      #
      # @param [Exception] exception
      #
      # @return [nil]
      #
      def notify_to_stdout: (Exception exception) -> void

      #
      # Convert exception to attachments (for Slack)
      #
      # @param [Exception] exception
      # @param [String] clean_message
      #
      # @return [Array<Hash>]
      #
      def to_attachments: (Exception exception, String clean_message) -> ::Array[{ color: untyped, text: untyped, fields: untyped, :mrkdwn_in => ::Array["text" | "fields"] }]

      #
      # Convert exception class to text
      #
      # @param [Class<Exception>] exception_class
      #
      # @return [String]
      #
      def to_text: (singleton(Exception) exception_class) -> ::String

      #
      # Convert clean_message and backtrace into fields (for Slack)
      #
      # @param [String] clean_message
      # @param [Array] backtrace
      #
      # @return [Array<Hash>]
      #
      def to_fields: (String clean_message, untyped backtrace) -> Array[Hash[(String | Symbol), untyped]]

      #
      # Hostname of runnning instance
      #
      # @return [String]
      #
      def hostname: () -> String

      #
      # Format backtrace in string
      #
      # @param [Array] backtrace
      #
      # @return [String]
      #
      def format_backtrace: (untyped backtrace) -> (nil | ::String)
    end
  end
end
